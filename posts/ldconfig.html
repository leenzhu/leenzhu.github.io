<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="leen"><meta name=description content="工作时遇到了一个奇的问题。手动创建某个so符号链接似乎不能被ldconfig识别。
"><meta name=keywords content="leen,leenzhu,blog,博客,笔记,教程,vpp,编程,golang,C,js,javascript"><link rel=canonical href=https://leenzhu.com/posts/ldconfig.html><title>ldconfig &#183; Leen Zhu</title><link rel="shortcut icon" href=/image/logo.png><link rel=stylesheet href=/css/normalize.css><link rel=stylesheet href=/css/chroma.css><link rel=stylesheet href=/scss/sun.min.173be92a65a018529d78026ec3240959d2a3dd35b070c391cad265c861d20173.css integrity="sha256-FzvpKmWgGFKdeAJuwyQJWdKj3TWwcMORytJlyGHSAXM=" crossorigin=anonymous></head><body><div class=main><header class="header clearfix"><a href=/ class=site-logo><img src=/image/logo.png></img></a><div class=site-info><h1 class=site-name><a href=/>Leen Zhu</a></h1><p class=site-description>while(life--) money++;</p></div><nav class=site-nav><a href=/>首页</a>
<a href=/posts.html>归档</a>
<a href=/categories.html>分类</a>
<a href=/tags.html>标签</a>
<a href=/about.html>关于</a></nav></header><div class=content><div class=post-page><div class=print-url>https://leenzhu.com/posts/ldconfig.html</div><h1><a href=/posts/ldconfig.html>ldconfig</a></h1><div class=post-meta><span class=date>2024-09-23</span></div><hr><div class=post-content><p>工作时遇到了一个奇的问题。手动创建某个<code>so</code>符号链接似乎不能被<code>ldconfig</code>识别。</p><p>事情的起因为是这样的，我有一个程序P，通过<code>ldd</code>检查，它明确依赖<code>libcrypto.so.1.0.0</code>，我的系统中只有这几个<code>so</code>：</p><pre tabindex=0><code>libcrypto.so
libcrypto.so.1.1
libcrypto.so.1.1.1k
</code></pre><p>所以最开始的想着建立一个符号链接就可以了，因为我在系统中只有<code>libcrypto.so.1.0.2k</code>的时候成功过。所以我在<code>/lib64</code>目录中创建了一个符号链接：</p><pre tabindex=0><code>[root@localhost certus]# ll /lib64/  | grep libcrypto
lrwxrwxrwx.  1 root root       19 Dec 18  2023 libcrypto.so -&gt; libcrypto.so.1.1.1k
lrwxrwxrwx.  1 root root       26 Sep 23 05:17 libcrypto.so.1.0.0 -&gt; /lib64/libcrypto.so.1.1.1k
lrwxrwxrwx.  1 root root       19 Dec 18  2023 libcrypto.so.1.1 -&gt; libcrypto.so.1.1.1k
-rwxr-xr-x.  1 root root  3087888 Dec 18  2023 libcrypto.so.1.1.1k
</code></pre><p>然后这样并没有达到预期效果，我的程序P无法运行。我知道这个应该是版本太高的原因。</p><p>所以我从其它机器上复了较低版本<code>libcrypt.so.1.0.2k</code>，然后给它创建了符号链接<code>libcrypt.1.0.0</code>，最后运行一下程序，发现可以正常运行。本来事情到这里就可以结束了。但是我觉得直接在系统的<code>/lib64</code>目录中新文件的方式不太好，不如单独指定一个目录，然后通过<code>ldconfig</code>来更新依赖库。于是我就遇到了一个困扰我一天的问题。</p><p>操作流程如下：</p><ol><li>新建一个目录<code>/usr/local/lib64/foo</code></li><li>将<code>libcrpyto.so.1.0.2k</code>复制到<code>/usr/local/lib64/foo</code>目录中</li><li>将<code>libcrypto.so.1.0.0</code>符号链接复制到<code>/usr/local/lib64/foo</code>目录中</li><li>新建一个<code>ldconfig</code>配置文件<code>/etc/ld.so.conf.d/foo.conf</code>，内容为：<code>/usr/local/lib64/foo</code></li><li>执行<code>ldconfig</code> 命令。</li></ol><p>操作完上述流程后，我再次运行我的程序P，发现依然找不到<code>libcrypto.so.1.0.0</code>。那么为什么<code>/usr/local/lib64/foo</code>目录中的<code>libcrypto.so.1.0.0</code>这个符号没有被找到呢？通过<code>ldconfig -v</code>查看，发现<code>ldconfig</code>根据<code>libcrypto.so.1.0.2k</code>生成了<code>libcrpyto.so.10</code>这个符号，而这个符号是可以被识别的。而我自己手动创建的符号<code>libcrypto.so.1.0.0</code>却不能工作。我猜测肯定是有什么原因导致<code>ldconfig</code>没有识别我的符号链接。于是我又偿试不用符号链接，直接把<code>libcrypt.so.1.0.2k</code>重命名成<code>libcrypto.so.1.0.0</code>，但是这样依然不能生效。</p><p>通过调试，发现<code>search cache=/etc/ld.so.cache</code>里面就没有<code>libcrypto.so.1.0.0</code>：</p><pre tabindex=0><code> LD_DEBUG=libs /path/to/progP
</code></pre><p>后来我在<code>/lib64</code>目录中创建符号链接<code>libcrypto.so.1.0.0</code>，这里的符号是可以被程序P找到的。</p><p>搜索了很多资料，也没有发现有什么能解释这个问题的。问了<code>chatgpt</code>，它跟我扯了一堆没用的，什么lib命名问题，权限的问题，优先级问题等等，都没有解决问题。</p><p>后来我想了一下，应该是和<code>ldconfig</code>的机制有关，想去看看<code>ldconfig</code>的源码，发现一时半会儿也理不清，就放弃了。但是我注意到<code>ldconfig</code>会根据<code>libcrypto.so.1.0.2k</code>自动生成符号链接<code>libcrypto.so.10</code>，为什么<code>ldconfig</code>自己生成的符号有效，而我手动创建的符号无效？我猜测<code>ldconfig</code>在搜索目录时，可能只会处理目录中有效的<code>SONAME</code>，我重新编译了一个 <code>libcrypto.so.1.0.0</code>，然后放入<code>/usr/local/lib64/foo</code>目录中，这次运行<code>ldconfig</code>就能识别这个库了。</p><p>经过上述偿试，我最终猜测<code>ldconfg</code>处理lib库的机制是：</p><ol><li><code>ldconfig</code>遍历指定的目录，只搜索不是符号链接的<code>lib*.so*</code>文件。</li><li>从对应的<code>lib*.so*</code>文件提取<code>SONAME</code>如果有<code>SONAME</code>，那么就根据<code>SONAME</code>创建对应的符号链接，如果<code>SONAME</code>与文件名同名，则不用创建。把对应的<code>SONAME</code>加入<code>ld.so.cache</code>。如果没有<code>SONAME</code>，那么就把该库本身加入<code>ld.so.cache</code>。</li></ol><p>这样就可以解释两点：</p><ol><li>直接在<code>/usr/local/lib64/foo</code>中手动创建符号链接不生效：因为<code>ldconfig</code>不处理符号链接。</li><li>将<code>libcrypto.so.1.0.2k</code>改名成<code>libcrypto.so.1.0.0</code>不生效：因为<code>ldconfig</code>会根据 <code>libcrypto.so.1.0.0</code> 中的 <code>SONAME</code> 生成对应的符号链接 <code>libcrypt.so.10</code> 所以只会把 <code>libcrypto.so.10</code> 加入 <code>ld.so.cache</code> 。</li></ol><p>至于为何直接在 <code>/lib64</code> 中手动创建符号可以生效，我猜测这个和 <code>ldconfig</code> 没有关系，因为 <code>/lib64</code> 是进程默认的 <code>so</code> 加载路径。所以可以直接找。通过 <code>LD_LIBRARY_PATH</code> 也可以指定程序搜索对应目录的 <code>so</code> 文件，也同样不需要 <code>ldconfig</code> 的参于。</p></div><div class=page-nav><a href=/posts/git-branch-points-at.html class="nav-btn page-next">git 根据commit反查branch、tag名</a></div><div class=comment style=clear:both;margin-top:5em></div></div></div></div><div class=footer><div class=copyright>@2019 <a href=https://leenzhu.com>LeenZhu</a></div><div class=powered_by>Power by <a href=http://www.gohugo.io/>Hugo</a>,
using <a href=https://github.com/leenzhu/hugo-theme-sun>Sun</a> Theme</div></div></body></html>